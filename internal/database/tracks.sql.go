// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tracks.sql

package database

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const addOriginalKey = `-- name: AddOriginalKey :exec
UPDATE tracks
SET
    original_key = $1
WHERE name = $2 AND artist = $3
`

type AddOriginalKeyParams struct {
	OriginalKey string
	Name        string
	Artist      string
}

func (q *Queries) AddOriginalKey(ctx context.Context, arg AddOriginalKeyParams) error {
	_, err := q.db.ExecContext(ctx, addOriginalKey, arg.OriginalKey, arg.Name, arg.Artist)
	return err
}

const addSingerToWorking = `-- name: AddSingerToWorking :exec
UPDATE working
SET 
    singer = $1,
    singer_key = $2
WHERE name = $3 AND artist = $4
`

type AddSingerToWorkingParams struct {
	Singer    sql.NullString
	SingerKey sql.NullString
	Name      string
	Artist    string
}

func (q *Queries) AddSingerToWorking(ctx context.Context, arg AddSingerToWorkingParams) error {
	_, err := q.db.ExecContext(ctx, addSingerToWorking,
		arg.Singer,
		arg.SingerKey,
		arg.Name,
		arg.Artist,
	)
	return err
}

const addToSingers = `-- name: AddToSingers :exec
INSERT INTO singers (song, artist, singer, key)
VALUES (
    $1,
    $2,
    $3,
    $4
)
`

type AddToSingersParams struct {
	Song   string
	Artist string
	Singer string
	Key    string
}

func (q *Queries) AddToSingers(ctx context.Context, arg AddToSingersParams) error {
	_, err := q.db.ExecContext(ctx, addToSingers,
		arg.Song,
		arg.Artist,
		arg.Singer,
		arg.Key,
	)
	return err
}

const addTrackToWorking = `-- name: AddTrackToWorking :exec
INSERT INTO working (name, artist, genre, duration_in_seconds, year, explicit, bpm, original_key)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
)
`

type AddTrackToWorkingParams struct {
	Name              string
	Artist            string
	Genre             []string
	DurationInSeconds int32
	Year              string
	Explicit          bool
	Bpm               int32
	OriginalKey       string
}

func (q *Queries) AddTrackToWorking(ctx context.Context, arg AddTrackToWorkingParams) error {
	_, err := q.db.ExecContext(ctx, addTrackToWorking,
		arg.Name,
		arg.Artist,
		pq.Array(arg.Genre),
		arg.DurationInSeconds,
		arg.Year,
		arg.Explicit,
		arg.Bpm,
		arg.OriginalKey,
	)
	return err
}

const checkKeys = `-- name: CheckKeys :many
SELECT name, artist FROM tracks WHERE original_key = '' OR original_key IS NULL
`

type CheckKeysRow struct {
	Name   string
	Artist string
}

func (q *Queries) CheckKeys(ctx context.Context) ([]CheckKeysRow, error) {
	rows, err := q.db.QueryContext(ctx, checkKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CheckKeysRow
	for rows.Next() {
		var i CheckKeysRow
		if err := rows.Scan(&i.Name, &i.Artist); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const checkSingers = `-- name: CheckSingers :one
SELECT NOT EXISTS (
  SELECT 1 FROM singers WHERE song = $1 AND artist = $2
)
`

type CheckSingersParams struct {
	Song   string
	Artist string
}

func (q *Queries) CheckSingers(ctx context.Context, arg CheckSingersParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkSingers, arg.Song, arg.Artist)
	var not_exists bool
	err := row.Scan(&not_exists)
	return not_exists, err
}

const cleanupTracks = `-- name: CleanupTracks :exec
DELETE FROM tracks WHERE tracks.original_key = ''
`

func (q *Queries) CleanupTracks(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupTracks)
	return err
}

const cleanupWorking = `-- name: CleanupWorking :exec
DELETE FROM working
`

func (q *Queries) CleanupWorking(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupWorking)
	return err
}

const createTrack = `-- name: CreateTrack :exec
INSERT INTO tracks (name, artist, genre, duration_in_seconds, year, explicit, bpm, original_key)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
)
`

type CreateTrackParams struct {
	Name              string
	Artist            string
	Genre             []string
	DurationInSeconds int32
	Year              string
	Explicit          bool
	Bpm               int32
	OriginalKey       string
}

func (q *Queries) CreateTrack(ctx context.Context, arg CreateTrackParams) error {
	_, err := q.db.ExecContext(ctx, createTrack,
		arg.Name,
		arg.Artist,
		pq.Array(arg.Genre),
		arg.DurationInSeconds,
		arg.Year,
		arg.Explicit,
		arg.Bpm,
		arg.OriginalKey,
	)
	return err
}

const deleteTrack = `-- name: DeleteTrack :exec
DELETE FROM tracks WHERE tracks.name = $1 AND tracks.artist = $2
`

type DeleteTrackParams struct {
	Name   string
	Artist string
}

func (q *Queries) DeleteTrack(ctx context.Context, arg DeleteTrackParams) error {
	_, err := q.db.ExecContext(ctx, deleteTrack, arg.Name, arg.Artist)
	return err
}

const getAllTracks = `-- name: GetAllTracks :many
SELECT name, artist, genre, duration_in_seconds, year, explicit, bpm, original_key FROM tracks
`

func (q *Queries) GetAllTracks(ctx context.Context) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, getAllTracks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.Name,
			&i.Artist,
			pq.Array(&i.Genre),
			&i.DurationInSeconds,
			&i.Year,
			&i.Explicit,
			&i.Bpm,
			&i.OriginalKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllWorking = `-- name: GetAllWorking :many
SELECT name, artist, genre, duration_in_seconds, year, explicit, bpm, original_key, singer, singer_key FROM working
`

func (q *Queries) GetAllWorking(ctx context.Context) ([]Working, error) {
	rows, err := q.db.QueryContext(ctx, getAllWorking)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Working
	for rows.Next() {
		var i Working
		if err := rows.Scan(
			&i.Name,
			&i.Artist,
			pq.Array(&i.Genre),
			&i.DurationInSeconds,
			&i.Year,
			&i.Explicit,
			&i.Bpm,
			&i.OriginalKey,
			&i.Singer,
			&i.SingerKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSingerCombos = `-- name: GetSingerCombos :many
SELECT singer, key from singers WHERE song = $1 and artist = $2
`

type GetSingerCombosParams struct {
	Song   string
	Artist string
}

type GetSingerCombosRow struct {
	Singer string
	Key    string
}

func (q *Queries) GetSingerCombos(ctx context.Context, arg GetSingerCombosParams) ([]GetSingerCombosRow, error) {
	rows, err := q.db.QueryContext(ctx, getSingerCombos, arg.Song, arg.Artist)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSingerCombosRow
	for rows.Next() {
		var i GetSingerCombosRow
		if err := rows.Scan(&i.Singer, &i.Key); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrack = `-- name: GetTrack :one
SELECT name, artist, genre, duration_in_seconds, year, explicit, bpm, original_key FROM tracks WHERE tracks.name = $1 AND tracks.artist = $2
`

type GetTrackParams struct {
	Name   string
	Artist string
}

func (q *Queries) GetTrack(ctx context.Context, arg GetTrackParams) (Track, error) {
	row := q.db.QueryRowContext(ctx, getTrack, arg.Name, arg.Artist)
	var i Track
	err := row.Scan(
		&i.Name,
		&i.Artist,
		pq.Array(&i.Genre),
		&i.DurationInSeconds,
		&i.Year,
		&i.Explicit,
		&i.Bpm,
		&i.OriginalKey,
	)
	return i, err
}

const getTracksWithSingers = `-- name: GetTracksWithSingers :many
SELECT
    t.name,
    t.artist,
    t.genre,
    t.duration_in_seconds,
    t.year,
    t.explicit,
    t.bpm,
    t.original_key,
    s.singer,
    s.key AS singer_key
FROM
    tracks t
JOIN
    singers s ON t.name = s.song AND t.artist = s.artist
`

type GetTracksWithSingersRow struct {
	Name              string
	Artist            string
	Genre             []string
	DurationInSeconds int32
	Year              string
	Explicit          bool
	Bpm               int32
	OriginalKey       string
	Singer            string
	SingerKey         string
}

func (q *Queries) GetTracksWithSingers(ctx context.Context) ([]GetTracksWithSingersRow, error) {
	rows, err := q.db.QueryContext(ctx, getTracksWithSingers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTracksWithSingersRow
	for rows.Next() {
		var i GetTracksWithSingersRow
		if err := rows.Scan(
			&i.Name,
			&i.Artist,
			pq.Array(&i.Genre),
			&i.DurationInSeconds,
			&i.Year,
			&i.Explicit,
			&i.Bpm,
			&i.OriginalKey,
			&i.Singer,
			&i.SingerKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorking = `-- name: GetWorking :one
SELECT name, artist, genre, duration_in_seconds, year, explicit, bpm, original_key, singer, singer_key FROM working WHERE working.name = $1
`

func (q *Queries) GetWorking(ctx context.Context, name string) (Working, error) {
	row := q.db.QueryRowContext(ctx, getWorking, name)
	var i Working
	err := row.Scan(
		&i.Name,
		&i.Artist,
		pq.Array(&i.Genre),
		&i.DurationInSeconds,
		&i.Year,
		&i.Explicit,
		&i.Bpm,
		&i.OriginalKey,
		&i.Singer,
		&i.SingerKey,
	)
	return i, err
}

const removeFromWorking = `-- name: RemoveFromWorking :exec
DELETE FROM working WHERE working.name = $1
`

func (q *Queries) RemoveFromWorking(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, removeFromWorking, name)
	return err
}
